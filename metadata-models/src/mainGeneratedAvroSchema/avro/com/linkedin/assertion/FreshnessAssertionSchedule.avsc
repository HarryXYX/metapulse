{
  "type" : "record",
  "name" : "FreshnessAssertionSchedule",
  "namespace" : "com.linkedin.assertion",
  "doc" : "Attributes defining a single Freshness schedule.",
  "fields" : [ {
    "name" : "type",
    "type" : {
      "type" : "enum",
      "name" : "FreshnessAssertionScheduleType",
      "symbols" : [ "CRON", "FIXED_INTERVAL", "SINCE_THE_LAST_CHECK" ],
      "symbolDocs" : {
        "CRON" : "A highly configurable recurring schedule which describes the times of events described\nby a CRON schedule, with the evaluation schedule assuming to be matching the cron schedule.\n\nIn a CRON schedule type, we compute the look-back window to be the time between the last scheduled event\nand the current event (evaluation time). This means that the evaluation schedule must match exactly\nthe schedule defined inside the cron schedule.\n\nFor example, a CRON schedule defined as \"0 8 * * *\" would represent a schedule of \"every day by 8am\". Assuming\nthat the assertion evaluation schedule is defined to match this, the freshness assertion would be evaluated in the following way:\n\n    1. Compute the \"last scheduled occurrence\" of the event using the CRON schedule. For example, yesterday at 8am.\n    2. Compute the bounds of a time window between the \"last scheduled occurrence\" (yesterday at 8am) until the \"current occurrence\" (today at 8am)\n    3. Verify that the target event has occurred within the CRON-interval window.\n    4. If the target event has occurred within the time window, then assertion passes.\n    5. If the target event has not occurred within the time window, then the assertion fails.",
        "FIXED_INTERVAL" : "A fixed interval which is used to compute a look-back window for use when evaluating the assertion relative\nto the Evaluation Time of the Assertion.\n\nTo compute the valid look-back window, we subtract the fixed interval from the evaluation time. Then, we verify\nthat the target event has occurred within that window.\n\nFor example, a fixed interval of \"24h\" would represent a schedule of \"in the last 24 hours\".\nThe 24 hour interval is relative to the evaluation time of the assertion. For example if we schedule the assertion\nto be evaluated each hour, we'd compute the result as follows:\n\n    1. Subtract the fixed interval from the current time (Evaluation time) to compute the bounds of a fixed look-back window.\n    2. Verify that the target event has occurred within the look-back window.\n    3. If the target event has occurred within the time window, then assertion passes.\n    4. If the target event has not occurred within the time window, then the assertion fails.",
        "SINCE_THE_LAST_CHECK" : "A stateful check that takes the last time this check ran to determine the look-back window.\n\nTo compute the valid look-back- window, we start at the time the monitor last evaluated this assertion,\nand we end at the point in time the check is currently running.\n\nFor example, let's say a Freshness assertion is of type SINCE_THE_LAST_CHECK, and the monitor is configured to\nrun every day at 12:00am. Let's assume this assertion was last evaluated yesterday at 12:04am. We'd compute\nthe result as follows:\n\n    1. Get the timestamp for the last run of the monitor on this assertion.\n    2. look_back_window_start_time = latest_monitor_run.timestampMillis [ie. 12:04a yesterday]\n    3. look_back_window_end_time = nowMillis [ie. 12:02a today]\n    4. If the target event has occurred within the window [ie. 12:04a yday to 12:02a today],\n       then the assertion passes.\n    5. If the target event has not occurred within the window, then the assertion fails."
      }
    },
    "doc" : "The type of a Freshness Assertion Schedule.\n\nOnce we support data-time-relative schedules (e.g. schedules relative to time partitions),\nwe will add those schedule types here."
  }, {
    "name" : "cron",
    "type" : [ "null", {
      "type" : "record",
      "name" : "FreshnessCronSchedule",
      "doc" : "Attributes defining a CRON-formatted schedule used for defining a freshness assertion.",
      "fields" : [ {
        "name" : "cron",
        "type" : "string",
        "doc" : "A cron-formatted execution interval, as a cron string, e.g. 1 * * * *"
      }, {
        "name" : "timezone",
        "type" : "string",
        "doc" : "Timezone in which the cron interval applies, e.g. America/Los Angeles"
      }, {
        "name" : "windowStartOffsetMs",
        "type" : [ "null", "long" ],
        "doc" : "An optional offset in milliseconds to SUBTRACT from the timestamp generated by the cron schedule\nto generate the lower bounds of the \"freshness window\", or the window of time in which an event must have occurred in order for the Freshness check\nto be considering passing.\n\nIf left empty, the start of the SLA window will be the _end_ of the previously evaluated Freshness window.",
        "default" : null
      } ]
    } ],
    "doc" : "A cron schedule. This field is required when type is CRON.",
    "default" : null
  }, {
    "name" : "fixedInterval",
    "type" : [ "null", {
      "type" : "record",
      "name" : "FixedIntervalSchedule",
      "doc" : "Attributes defining a relative fixed interval SLA schedule.",
      "fields" : [ {
        "name" : "unit",
        "type" : {
          "type" : "enum",
          "name" : "CalendarInterval",
          "namespace" : "com.linkedin.timeseries",
          "symbols" : [ "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR" ]
        },
        "doc" : "Interval unit such as minute/hour/day etc."
      }, {
        "name" : "multiple",
        "type" : "int",
        "doc" : "How many units. Defaults to 1.",
        "default" : 1
      } ]
    } ],
    "doc" : "A fixed interval schedule. This field is required when type is FIXED_INTERVAL.",
    "default" : null
  } ]
}