{
  "type" : "record",
  "name" : "VolumeAssertionInfo",
  "namespace" : "com.linkedin.assertion",
  "doc" : "Attributes defining a dataset Volume Assertion",
  "fields" : [ {
    "name" : "type",
    "type" : {
      "type" : "enum",
      "name" : "VolumeAssertionType",
      "symbols" : [ "ROW_COUNT_TOTAL", "ROW_COUNT_CHANGE", "INCREMENTING_SEGMENT_ROW_COUNT_TOTAL", "INCREMENTING_SEGMENT_ROW_COUNT_CHANGE" ],
      "symbolDocs" : {
        "INCREMENTING_SEGMENT_ROW_COUNT_CHANGE" : "A volume assertion that compares the row counts in neighboring \"segments\" or \"partitions\"\nof an incrementing column.\nThis can be used to track changes between subsequent date partition\nin a table, for example.",
        "INCREMENTING_SEGMENT_ROW_COUNT_TOTAL" : "A volume assertion that checks the latest \"segment\" in a table based on an incrementing\ncolumn to check whether it's row count falls into a particular range.\n\nThis can be used to monitor the row count of an incrementing date-partition column segment.",
        "ROW_COUNT_CHANGE" : "A volume assertion that is evaluated against an incremental row count of a dataset,\nor a row count change.",
        "ROW_COUNT_TOTAL" : "A volume assertion that is evaluated against the total row count of a dataset."
      }
    },
    "doc" : "The type of the volume assertion being monitored.",
    "Searchable" : { }
  }, {
    "name" : "entity",
    "type" : "string",
    "doc" : "The entity targeted by this Volume check.",
    "Relationship" : {
      "entityTypes" : [ "dataset" ],
      "name" : "Asserts"
    },
    "Searchable" : {
      "fieldType" : "URN"
    },
    "java" : {
      "class" : "com.linkedin.common.urn.Urn"
    }
  }, {
    "name" : "rowCountTotal",
    "type" : [ "null", {
      "type" : "record",
      "name" : "RowCountTotal",
      "doc" : "Attributes defining a ROW_COUNT_TOTAL volume assertion.",
      "fields" : [ {
        "name" : "operator",
        "type" : {
          "type" : "enum",
          "name" : "AssertionStdOperator",
          "doc" : "A boolean operator that is applied on the input to an assertion, after an aggregation function has been applied.",
          "symbols" : [ "BETWEEN", "LESS_THAN", "LESS_THAN_OR_EQUAL_TO", "GREATER_THAN", "GREATER_THAN_OR_EQUAL_TO", "EQUAL_TO", "NOT_EQUAL_TO", "NULL", "NOT_NULL", "CONTAIN", "END_WITH", "START_WITH", "REGEX_MATCH", "IN", "NOT_IN", "IS_TRUE", "IS_FALSE", "_NATIVE_" ],
          "symbolDocs" : {
            "BETWEEN" : "Value being asserted is between min_value and max_value.  Requires 'minValue' & 'maxValue' parameters.",
            "CONTAIN" : "Value being asserted contains value. Requires 'value' parameter.",
            "END_WITH" : "Value being asserted ends with value. Requires 'value' parameter.",
            "EQUAL_TO" : "Value being asserted is equal to value. Requires 'value' parameter.",
            "GREATER_THAN" : "Value being asserted is greater than some value. Requires 'value' parameter.",
            "GREATER_THAN_OR_EQUAL_TO" : "Value being asserted is greater than or equal to some value. Requires 'value' parameter.",
            "IN" : "Value being asserted is one of the array values. Requires 'value' parameter.",
            "IS_FALSE" : "Value being asserted is false. Requires no parameters.",
            "IS_TRUE" : "Value being asserted is true. Requires no parameters.",
            "LESS_THAN" : "Value being asserted is less than a max value. Requires 'value' parameter.",
            "LESS_THAN_OR_EQUAL_TO" : "Value being asserted is less than or equal to some value. Requires 'value' parameter.",
            "NOT_EQUAL_TO" : "Value being asserted is not equal to value. Requires 'value' parameter.",
            "NOT_IN" : "Value being asserted is not in one of the array values. Requires 'value' parameter.",
            "NOT_NULL" : "Value being asserted is not null. Requires no parameters.",
            "NULL" : "Value being asserted is null. Requires no parameters.",
            "REGEX_MATCH" : "Value being asserted matches the regex value. Requires 'value' parameter.",
            "START_WITH" : "Value being asserted starts with value. Requires 'value' parameter.",
            "_NATIVE_" : "Other"
          }
        },
        "doc" : "The operator you'd like to apply.\n\nNote that only numeric operators are valid inputs:\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\nBETWEEN."
      }, {
        "name" : "parameters",
        "type" : {
          "type" : "record",
          "name" : "AssertionStdParameters",
          "doc" : "Parameters for AssertionStdOperators.",
          "fields" : [ {
            "name" : "value",
            "type" : [ "null", {
              "type" : "record",
              "name" : "AssertionStdParameter",
              "doc" : "Single parameter for AssertionStdOperators.",
              "fields" : [ {
                "name" : "value",
                "type" : "string",
                "doc" : "The parameter value"
              }, {
                "name" : "type",
                "type" : {
                  "type" : "enum",
                  "name" : "AssertionStdParameterType",
                  "symbols" : [ "STRING", "NUMBER", "LIST", "SET", "UNKNOWN" ],
                  "symbolDocs" : {
                    "LIST" : "A list of values. When used, value should be formatted as a serialized JSON array.",
                    "NUMBER" : "A numeric value",
                    "SET" : "A set of values. When used, value should be formatted as a serialized JSON array.",
                    "STRING" : "A string value",
                    "UNKNOWN" : "A value of unknown type"
                  }
                },
                "doc" : "The type of the parameter"
              } ]
            } ],
            "doc" : "The value parameter of an assertion",
            "default" : null
          }, {
            "name" : "maxValue",
            "type" : [ "null", "AssertionStdParameter" ],
            "doc" : "The maxValue parameter of an assertion",
            "default" : null
          }, {
            "name" : "minValue",
            "type" : [ "null", "AssertionStdParameter" ],
            "doc" : "The minValue parameter of an assertion",
            "default" : null
          } ]
        },
        "doc" : "The parameters you'd like to provide as input to the operator.\n\nNote that only numeric parameter types are valid inputs: NUMBER."
      } ]
    } ],
    "doc" : "Produce FAILURE Assertion Result if the row count of the asset does not meet specific requirements.\nRequired if type is 'ROW_COUNT_TOTAL'",
    "default" : null
  }, {
    "name" : "rowCountChange",
    "type" : [ "null", {
      "type" : "record",
      "name" : "RowCountChange",
      "doc" : "Attributes defining a ROW_COUNT_CHANGE volume assertion.",
      "fields" : [ {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "AssertionValueChangeType",
          "doc" : "An enum to represent a type of change in an assertion value, metric, or measurement.",
          "symbols" : [ "ABSOLUTE", "PERCENTAGE" ],
          "symbolDocs" : {
            "ABSOLUTE" : "A change that is defined in absolute terms.",
            "PERCENTAGE" : "A change that is defined in relative terms using percentage change\nfrom the original value."
          }
        },
        "doc" : "The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage."
      }, {
        "name" : "operator",
        "type" : "AssertionStdOperator",
        "doc" : "The operator you'd like to apply.\n\nNote that only numeric operators are valid inputs:\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\nBETWEEN."
      }, {
        "name" : "parameters",
        "type" : "AssertionStdParameters",
        "doc" : "The parameters you'd like to provide as input to the operator.\n\nNote that only numeric parameter types are valid inputs: NUMBER."
      } ]
    } ],
    "doc" : "Produce FAILURE Assertion Result if the delta row count of the asset does not meet specific requirements\nwithin a given period of time.\nRequired if type is 'ROW_COUNT_CHANGE'",
    "default" : null
  }, {
    "name" : "incrementingSegmentRowCountTotal",
    "type" : [ "null", {
      "type" : "record",
      "name" : "IncrementingSegmentRowCountTotal",
      "doc" : "Attributes defining an INCREMENTING_SEGMENT_ROW_COUNT_TOTAL volume assertion.",
      "fields" : [ {
        "name" : "segment",
        "type" : {
          "type" : "record",
          "name" : "IncrementingSegmentSpec",
          "doc" : "Core attributes required to identify an incrementing segment in a table. This type is mainly useful\nfor tables that constantly increase with new rows being added on a particular cadence (e.g. fact or event tables)\n\nAn incrementing segment represents a logical chunk of data which is INSERTED\ninto a dataset on a regular interval, along with the presence of a constantly-incrementing column\nvalue such as an event time, date partition, or last modified column.\n\nAn incrementing segment is principally identified by 2 key attributes combined:\n\n 1. A field or column that represents the incrementing value. New rows that are inserted will be identified using this column.\n    Note that the value of this column may not by itself represent the \"bucket\" or the \"segment\" in which the row falls.\n\n 2. [Optional] An transformer function that may be applied to the selected column value in order\n    to obtain the final \"segment identifier\" or \"bucket identifier\". Rows that have the same value after applying the transformation\n    will be grouped into the same segment, using which the final value (e.g. row count) will be determined.",
          "fields" : [ {
            "name" : "field",
            "type" : {
              "type" : "record",
              "name" : "SchemaFieldSpec",
              "namespace" : "com.linkedin.schema",
              "doc" : "Lightweight spec used for referencing a particular schema field.",
              "fields" : [ {
                "name" : "path",
                "type" : "string",
                "doc" : "The field path"
              }, {
                "name" : "type",
                "type" : "string",
                "doc" : "The DataHub standard schema field type."
              }, {
                "name" : "nativeType",
                "type" : "string",
                "doc" : "The native field type"
              } ]
            },
            "doc" : "The field to use to generate segments. It must be constantly incrementing as new rows are inserted."
          }, {
            "name" : "transformer",
            "type" : [ "null", {
              "type" : "record",
              "name" : "IncrementingSegmentFieldTransformer",
              "doc" : "The definition of the transformer function  that should be applied to a given field / column value in a dataset\nin order to determine the segment or bucket that it belongs to, which in turn is used to evaluate\nvolume assertions.",
              "fields" : [ {
                "name" : "type",
                "type" : {
                  "type" : "enum",
                  "name" : "IncrementingSegmentFieldTransformerType",
                  "symbols" : [ "TIMESTAMP_MS_TO_MINUTE", "TIMESTAMP_MS_TO_HOUR", "TIMESTAMP_MS_TO_DATE", "TIMESTAMP_MS_TO_MONTH", "TIMESTAMP_MS_TO_YEAR", "FLOOR", "CEILING", "NATIVE" ],
                  "symbolDocs" : {
                    "CEILING" : "Rounds a numeric value up to the nearest integer.",
                    "FLOOR" : "Rounds a numeric value down to the nearest integer.",
                    "NATIVE" : "A backdoor to provide a native operator type specific to a given source system like\nSnowflake, Redshift, BQ, etc.",
                    "TIMESTAMP_MS_TO_DATE" : "Rounds a timestamp (in milliseconds) down to the start of the day.",
                    "TIMESTAMP_MS_TO_HOUR" : "Rounds a timestamp (in milliseconds) down to the nearest hour.",
                    "TIMESTAMP_MS_TO_MINUTE" : "Rounds a timestamp (in seconds) down to the start of the month.",
                    "TIMESTAMP_MS_TO_MONTH" : "Rounds a timestamp (in milliseconds) down to the start of the month",
                    "TIMESTAMP_MS_TO_YEAR" : "Rounds a timestamp (in milliseconds) down to the start of the year"
                  }
                },
                "doc" : "A 'standard' transformer type. Note that not all source systems will support all operators."
              }, {
                "name" : "nativeType",
                "type" : [ "null", "string" ],
                "doc" : "The 'native' transformer type, useful as a back door if a custom operator is required.\nThis field is required if the type is NATIVE.",
                "default" : null
              } ]
            } ],
            "doc" : "Optional transformer function to apply to the field in order to obtain the final segment or bucket identifier.\nIf not provided, then no operator will be applied to the field. (identity function)",
            "default" : null
          } ]
        },
        "doc" : "A specification of how the 'segment' can be derived using a column and an optional transformer function."
      }, {
        "name" : "operator",
        "type" : "AssertionStdOperator",
        "doc" : "The operator you'd like to apply.\n\nNote that only numeric operators are valid inputs:\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\nBETWEEN."
      }, {
        "name" : "parameters",
        "type" : "AssertionStdParameters",
        "doc" : "The parameters you'd like to provide as input to the operator.\n\nNote that only numeric parameter types are valid inputs: NUMBER."
      } ]
    } ],
    "doc" : "Produce FAILURE Assertion Result if the asset's latest incrementing segment row count total\ndoes not meet specific requirements. Required if type is 'INCREMENTING_SEGMENT_ROW_COUNT_TOTAL'",
    "default" : null
  }, {
    "name" : "incrementingSegmentRowCountChange",
    "type" : [ "null", {
      "type" : "record",
      "name" : "IncrementingSegmentRowCountChange",
      "doc" : "Attributes defining an INCREMENTING_SEGMENT_ROW_COUNT_CHANGE volume assertion.",
      "fields" : [ {
        "name" : "segment",
        "type" : "IncrementingSegmentSpec",
        "doc" : "A specification of how the 'segment' can be derived using a column and an optional transformer function."
      }, {
        "name" : "type",
        "type" : "AssertionValueChangeType",
        "doc" : "The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage."
      }, {
        "name" : "operator",
        "type" : "AssertionStdOperator",
        "doc" : "The operator you'd like to apply to the row count value\n\nNote that only numeric operators are valid inputs:\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\nBETWEEN."
      }, {
        "name" : "parameters",
        "type" : "AssertionStdParameters",
        "doc" : "The parameters you'd like to provide as input to the operator.\n\nNote that only numeric parameter types are valid inputs: NUMBER."
      } ]
    } ],
    "doc" : "Produce FAILURE Assertion Result if the asset's incrementing segment row count delta\ndoes not meet specific requirements. Required if type is 'INCREMENTING_SEGMENT_ROW_COUNT_CHANGE'",
    "default" : null
  }, {
    "name" : "filter",
    "type" : [ "null", {
      "type" : "record",
      "name" : "DatasetFilter",
      "namespace" : "com.linkedin.dataset",
      "doc" : "A definition of filters that should be used when\nquerying an external Dataset or Table.\n\nNote that this models should NOT be used for working with\nsearch / filter on DataHub Platform itself.",
      "fields" : [ {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "DatasetFilterType",
          "symbols" : [ "SQL" ],
          "symbolDocs" : {
            "SQL" : "The partition is represented as a an opaque, raw SQL\nclause."
          }
        },
        "doc" : "How the partition will be represented in this model.\n\nIn the future, we'll likely add support for more structured\npredicates."
      }, {
        "name" : "sql",
        "type" : [ "null", "string" ],
        "doc" : "The raw where clause string which will be used for monitoring.\nRequired if the type is SQL.",
        "default" : null
      } ]
    } ],
    "doc" : "A definition of the specific filters that should be applied, when performing monitoring.\nIf not provided, there is no filter, and the full table is under consideration.",
    "default" : null
  } ]
}