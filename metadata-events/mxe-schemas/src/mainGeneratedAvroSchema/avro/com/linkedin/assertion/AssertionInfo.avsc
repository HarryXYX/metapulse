{
  "type" : "record",
  "name" : "AssertionInfo",
  "namespace" : "com.linkedin.assertion",
  "doc" : "Information about an assertion",
  "fields" : [ {
    "name" : "customProperties",
    "type" : {
      "type" : "map",
      "values" : "string"
    },
    "doc" : "Custom property bag.",
    "default" : { },
    "Searchable" : {
      "/*" : {
        "fieldType" : "TEXT",
        "queryByDefault" : true
      }
    }
  }, {
    "name" : "externalUrl",
    "type" : [ "null", "string" ],
    "doc" : "URL where the reference exist",
    "default" : null,
    "Searchable" : {
      "fieldType" : "KEYWORD"
    },
    "java" : {
      "class" : "com.linkedin.common.url.Url",
      "coercerClass" : "com.linkedin.common.url.UrlCoercer"
    }
  }, {
    "name" : "type",
    "type" : {
      "type" : "enum",
      "name" : "AssertionType",
      "symbols" : [ "DATASET", "FRESHNESS", "VOLUME", "SQL", "FIELD", "DATA_SCHEMA", "CUSTOM" ],
      "symbolDocs" : {
        "CUSTOM" : "A custom assertion. \nWhen this is the value, the customAssertion field will be populated.\nUse this assertion type when the exact type of assertion is not modeled in DataHub or\nas a starting point when integrating third-party data quality tools.",
        "DATASET" : "A single-dataset assertion.\nWhen this is the value, the datasetAssertion field will be populated.",
        "DATA_SCHEMA" : "A schema or structural assertion.\n\nWould have named this SCHEMA but the codegen for PDL does not allow this (reserved word).",
        "FIELD" : "A structured assertion targeting a specific column or field of the Dataset.",
        "FRESHNESS" : "A freshness assertion, or an assertion which indicates when a particular operation should occur\nto an asset.",
        "SQL" : "A raw SQL-statement based assertion",
        "VOLUME" : "A volume assertion, or an assertion which indicates how much data should be available for a\nparticular asset."
      }
    },
    "doc" : "Type of assertion. Assertion types can evolve to span Datasets, Flows (Pipelines), Models, Features etc.",
    "Searchable" : { }
  }, {
    "name" : "datasetAssertion",
    "type" : [ "null", {
      "type" : "record",
      "name" : "DatasetAssertionInfo",
      "doc" : "Attributes that are applicable to single-Dataset Assertions",
      "fields" : [ {
        "name" : "dataset",
        "type" : "string",
        "doc" : "The dataset targeted by this assertion.",
        "Relationship" : {
          "entityTypes" : [ "dataset" ],
          "name" : "Asserts"
        },
        "java" : {
          "class" : "com.linkedin.common.urn.Urn"
        }
      }, {
        "name" : "scope",
        "type" : {
          "type" : "enum",
          "name" : "DatasetAssertionScope",
          "symbols" : [ "DATASET_COLUMN", "DATASET_ROWS", "DATASET_STORAGE_SIZE", "DATASET_SCHEMA", "UNKNOWN" ],
          "symbolDocs" : {
            "DATASET_COLUMN" : "This assertion applies to dataset column(s)",
            "DATASET_ROWS" : "This assertion applies to entire rows of the dataset",
            "DATASET_SCHEMA" : "This assertion applies to the schema of the dataset",
            "DATASET_STORAGE_SIZE" : "This assertion applies to the storage size of the dataset",
            "UNKNOWN" : "The scope of the assertion is unknown"
          }
        },
        "doc" : "Scope of the Assertion. What part of the dataset does this assertion apply to?",
        "Searchable" : { }
      }, {
        "name" : "fields",
        "type" : [ "null", {
          "type" : "array",
          "items" : "string"
        } ],
        "doc" : "One or more dataset schema fields that are targeted by this assertion.\n\nThis field is expected to be provided if the assertion scope is DATASET_COLUMN.",
        "default" : null,
        "Relationship" : {
          "/*" : {
            "entityTypes" : [ "schemaField" ],
            "name" : "Asserts"
          }
        },
        "Searchable" : {
          "/*" : {
            "fieldType" : "URN"
          }
        }
      }, {
        "name" : "aggregation",
        "type" : [ "null", {
          "type" : "enum",
          "name" : "AssertionStdAggregation",
          "doc" : "The function that is applied to the aggregation input (schema, rows, column values) before evaluating an operator.",
          "symbols" : [ "ROW_COUNT", "COLUMNS", "COLUMN_COUNT", "IDENTITY", "MEAN", "MEDIAN", "UNIQUE_COUNT", "UNIQUE_PROPORTION", "UNIQUE_PROPOTION", "NULL_COUNT", "NULL_PROPORTION", "STDDEV", "MIN", "MAX", "SUM", "_NATIVE_" ],
          "symbolDocs" : {
            "COLUMNS" : "Assertion is applied on all columns.",
            "COLUMN_COUNT" : "Assertion is applied on number of columns.",
            "IDENTITY" : "Assertion is applied on individual column value. (No aggregation)",
            "MAX" : "Assertion is applied on column std deviation",
            "MEAN" : "Assertion is applied on column mean",
            "MEDIAN" : "Assertion is applied on column median",
            "MIN" : "Assertion is applied on column min",
            "NULL_COUNT" : "Assertion is applied on number of null values in column",
            "NULL_PROPORTION" : "Assertion is applied on proportion of null values in column",
            "ROW_COUNT" : "Assertion is applied on number of rows.",
            "STDDEV" : "Assertion is applied on column std deviation",
            "SUM" : "Assertion is applied on column sum",
            "UNIQUE_COUNT" : "Assertion is applied on number of distinct values in column",
            "UNIQUE_PROPORTION" : "Assertion is applied on proportion of distinct values in column",
            "UNIQUE_PROPOTION" : "Assertion is applied on proportion of distinct values in column\n\nDeprecated! Use UNIQUE_PROPORTION instead.",
            "_NATIVE_" : "Other"
          }
        } ],
        "doc" : "Standardized assertion operator\nThis field is left blank if there is no selected aggregation or metric for a particular column.",
        "default" : null,
        "Searchable" : { }
      }, {
        "name" : "operator",
        "type" : {
          "type" : "enum",
          "name" : "AssertionStdOperator",
          "doc" : "A boolean operator that is applied on the input to an assertion, after an aggregation function has been applied.",
          "symbols" : [ "BETWEEN", "LESS_THAN", "LESS_THAN_OR_EQUAL_TO", "GREATER_THAN", "GREATER_THAN_OR_EQUAL_TO", "EQUAL_TO", "NOT_EQUAL_TO", "NULL", "NOT_NULL", "CONTAIN", "END_WITH", "START_WITH", "REGEX_MATCH", "IN", "NOT_IN", "IS_TRUE", "IS_FALSE", "_NATIVE_" ],
          "symbolDocs" : {
            "BETWEEN" : "Value being asserted is between min_value and max_value.  Requires 'minValue' & 'maxValue' parameters.",
            "CONTAIN" : "Value being asserted contains value. Requires 'value' parameter.",
            "END_WITH" : "Value being asserted ends with value. Requires 'value' parameter.",
            "EQUAL_TO" : "Value being asserted is equal to value. Requires 'value' parameter.",
            "GREATER_THAN" : "Value being asserted is greater than some value. Requires 'value' parameter.",
            "GREATER_THAN_OR_EQUAL_TO" : "Value being asserted is greater than or equal to some value. Requires 'value' parameter.",
            "IN" : "Value being asserted is one of the array values. Requires 'value' parameter.",
            "IS_FALSE" : "Value being asserted is false. Requires no parameters.",
            "IS_TRUE" : "Value being asserted is true. Requires no parameters.",
            "LESS_THAN" : "Value being asserted is less than a max value. Requires 'value' parameter.",
            "LESS_THAN_OR_EQUAL_TO" : "Value being asserted is less than or equal to some value. Requires 'value' parameter.",
            "NOT_EQUAL_TO" : "Value being asserted is not equal to value. Requires 'value' parameter.",
            "NOT_IN" : "Value being asserted is not in one of the array values. Requires 'value' parameter.",
            "NOT_NULL" : "Value being asserted is not null. Requires no parameters.",
            "NULL" : "Value being asserted is null. Requires no parameters.",
            "REGEX_MATCH" : "Value being asserted matches the regex value. Requires 'value' parameter.",
            "START_WITH" : "Value being asserted starts with value. Requires 'value' parameter.",
            "_NATIVE_" : "Other"
          }
        },
        "doc" : "Standardized assertion operator"
      }, {
        "name" : "parameters",
        "type" : [ "null", {
          "type" : "record",
          "name" : "AssertionStdParameters",
          "doc" : "Parameters for AssertionStdOperators.",
          "fields" : [ {
            "name" : "value",
            "type" : [ "null", {
              "type" : "record",
              "name" : "AssertionStdParameter",
              "doc" : "Single parameter for AssertionStdOperators.",
              "fields" : [ {
                "name" : "value",
                "type" : "string",
                "doc" : "The parameter value"
              }, {
                "name" : "type",
                "type" : {
                  "type" : "enum",
                  "name" : "AssertionStdParameterType",
                  "symbols" : [ "STRING", "NUMBER", "LIST", "SET", "UNKNOWN" ],
                  "symbolDocs" : {
                    "LIST" : "A list of values. When used, value should be formatted as a serialized JSON array.",
                    "NUMBER" : "A numeric value",
                    "SET" : "A set of values. When used, value should be formatted as a serialized JSON array.",
                    "STRING" : "A string value",
                    "UNKNOWN" : "A value of unknown type"
                  }
                },
                "doc" : "The type of the parameter"
              } ]
            } ],
            "doc" : "The value parameter of an assertion",
            "default" : null
          }, {
            "name" : "maxValue",
            "type" : [ "null", "AssertionStdParameter" ],
            "doc" : "The maxValue parameter of an assertion",
            "default" : null
          }, {
            "name" : "minValue",
            "type" : [ "null", "AssertionStdParameter" ],
            "doc" : "The minValue parameter of an assertion",
            "default" : null
          } ]
        } ],
        "doc" : "Standard parameters required for the assertion. e.g. min_value, max_value, value, columns",
        "default" : null
      }, {
        "name" : "nativeType",
        "type" : [ "null", "string" ],
        "doc" : "Native assertion type",
        "default" : null
      }, {
        "name" : "nativeParameters",
        "type" : [ "null", {
          "type" : "map",
          "values" : "string"
        } ],
        "doc" : "Native parameters required for the assertion.",
        "default" : null
      }, {
        "name" : "logic",
        "type" : [ "null", "string" ],
        "default" : null
      } ]
    } ],
    "doc" : "A Dataset Assertion definition. This field is populated when the type is DATASET.",
    "default" : null
  }, {
    "name" : "freshnessAssertion",
    "type" : [ "null", {
      "type" : "record",
      "name" : "FreshnessAssertionInfo",
      "doc" : "Attributes defining a Freshness Assertion.",
      "fields" : [ {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "FreshnessAssertionType",
          "symbols" : [ "DATASET_CHANGE", "DATA_JOB_RUN" ],
          "symbolDocs" : {
            "DATASET_CHANGE" : "An Freshness based on Operations performed on a particular Dataset (insert, update, delete, etc) and sourced from an audit log, as\nopposed to based on the highest watermark in a timestamp column (e.g. a query). Only valid when entity is of type \"dataset\".",
            "DATA_JOB_RUN" : "An Freshness based on a successful execution of a Data Job."
          }
        },
        "doc" : "The type of the freshness assertion being monitored.",
        "Searchable" : { }
      }, {
        "name" : "entity",
        "type" : "string",
        "doc" : "The entity targeted by this Freshness check.",
        "Relationship" : {
          "entityTypes" : [ "dataset", "dataJob" ],
          "name" : "Asserts"
        },
        "Searchable" : {
          "fieldType" : "URN"
        },
        "java" : {
          "class" : "com.linkedin.common.urn.Urn"
        }
      }, {
        "name" : "schedule",
        "type" : {
          "type" : "record",
          "name" : "FreshnessAssertionSchedule",
          "doc" : "Attributes defining a single Freshness schedule.",
          "fields" : [ {
            "name" : "type",
            "type" : {
              "type" : "enum",
              "name" : "FreshnessAssertionScheduleType",
              "symbols" : [ "CRON", "FIXED_INTERVAL", "SINCE_THE_LAST_CHECK" ],
              "symbolDocs" : {
                "CRON" : "A highly configurable recurring schedule which describes the times of events described\nby a CRON schedule, with the evaluation schedule assuming to be matching the cron schedule.\n\nIn a CRON schedule type, we compute the look-back window to be the time between the last scheduled event\nand the current event (evaluation time). This means that the evaluation schedule must match exactly\nthe schedule defined inside the cron schedule.\n\nFor example, a CRON schedule defined as \"0 8 * * *\" would represent a schedule of \"every day by 8am\". Assuming\nthat the assertion evaluation schedule is defined to match this, the freshness assertion would be evaluated in the following way:\n\n    1. Compute the \"last scheduled occurrence\" of the event using the CRON schedule. For example, yesterday at 8am.\n    2. Compute the bounds of a time window between the \"last scheduled occurrence\" (yesterday at 8am) until the \"current occurrence\" (today at 8am)\n    3. Verify that the target event has occurred within the CRON-interval window.\n    4. If the target event has occurred within the time window, then assertion passes.\n    5. If the target event has not occurred within the time window, then the assertion fails.",
                "FIXED_INTERVAL" : "A fixed interval which is used to compute a look-back window for use when evaluating the assertion relative\nto the Evaluation Time of the Assertion.\n\nTo compute the valid look-back window, we subtract the fixed interval from the evaluation time. Then, we verify\nthat the target event has occurred within that window.\n\nFor example, a fixed interval of \"24h\" would represent a schedule of \"in the last 24 hours\".\nThe 24 hour interval is relative to the evaluation time of the assertion. For example if we schedule the assertion\nto be evaluated each hour, we'd compute the result as follows:\n\n    1. Subtract the fixed interval from the current time (Evaluation time) to compute the bounds of a fixed look-back window.\n    2. Verify that the target event has occurred within the look-back window.\n    3. If the target event has occurred within the time window, then assertion passes.\n    4. If the target event has not occurred within the time window, then the assertion fails.",
                "SINCE_THE_LAST_CHECK" : "A stateful check that takes the last time this check ran to determine the look-back window.\n\nTo compute the valid look-back- window, we start at the time the monitor last evaluated this assertion,\nand we end at the point in time the check is currently running.\n\nFor example, let's say a Freshness assertion is of type SINCE_THE_LAST_CHECK, and the monitor is configured to\nrun every day at 12:00am. Let's assume this assertion was last evaluated yesterday at 12:04am. We'd compute\nthe result as follows:\n\n    1. Get the timestamp for the last run of the monitor on this assertion.\n    2. look_back_window_start_time = latest_monitor_run.timestampMillis [ie. 12:04a yesterday]\n    3. look_back_window_end_time = nowMillis [ie. 12:02a today]\n    4. If the target event has occurred within the window [ie. 12:04a yday to 12:02a today],\n       then the assertion passes.\n    5. If the target event has not occurred within the window, then the assertion fails."
              }
            },
            "doc" : "The type of a Freshness Assertion Schedule.\n\nOnce we support data-time-relative schedules (e.g. schedules relative to time partitions),\nwe will add those schedule types here."
          }, {
            "name" : "cron",
            "type" : [ "null", {
              "type" : "record",
              "name" : "FreshnessCronSchedule",
              "doc" : "Attributes defining a CRON-formatted schedule used for defining a freshness assertion.",
              "fields" : [ {
                "name" : "cron",
                "type" : "string",
                "doc" : "A cron-formatted execution interval, as a cron string, e.g. 1 * * * *"
              }, {
                "name" : "timezone",
                "type" : "string",
                "doc" : "Timezone in which the cron interval applies, e.g. America/Los Angeles"
              }, {
                "name" : "windowStartOffsetMs",
                "type" : [ "null", "long" ],
                "doc" : "An optional offset in milliseconds to SUBTRACT from the timestamp generated by the cron schedule\nto generate the lower bounds of the \"freshness window\", or the window of time in which an event must have occurred in order for the Freshness check\nto be considering passing.\n\nIf left empty, the start of the SLA window will be the _end_ of the previously evaluated Freshness window.",
                "default" : null
              } ]
            } ],
            "doc" : "A cron schedule. This field is required when type is CRON.",
            "default" : null
          }, {
            "name" : "fixedInterval",
            "type" : [ "null", {
              "type" : "record",
              "name" : "FixedIntervalSchedule",
              "doc" : "Attributes defining a relative fixed interval SLA schedule.",
              "fields" : [ {
                "name" : "unit",
                "type" : {
                  "type" : "enum",
                  "name" : "CalendarInterval",
                  "namespace" : "com.linkedin.timeseries",
                  "symbols" : [ "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR" ]
                },
                "doc" : "Interval unit such as minute/hour/day etc."
              }, {
                "name" : "multiple",
                "type" : "int",
                "doc" : "How many units. Defaults to 1.",
                "default" : 1
              } ]
            } ],
            "doc" : "A fixed interval schedule. This field is required when type is FIXED_INTERVAL.",
            "default" : null
          } ]
        },
        "doc" : "Produce FAILURE Assertion Result if the asset is not updated on the cadence and within the time range described by the schedule.",
        "Searchable" : {
          "/type" : {
            "fieldName" : "scheduleType"
          }
        }
      }, {
        "name" : "filter",
        "type" : [ "null", {
          "type" : "record",
          "name" : "DatasetFilter",
          "namespace" : "com.linkedin.dataset",
          "doc" : "A definition of filters that should be used when\nquerying an external Dataset or Table.\n\nNote that this models should NOT be used for working with\nsearch / filter on DataHub Platform itself.",
          "fields" : [ {
            "name" : "type",
            "type" : {
              "type" : "enum",
              "name" : "DatasetFilterType",
              "symbols" : [ "SQL" ],
              "symbolDocs" : {
                "SQL" : "The partition is represented as a an opaque, raw SQL\nclause."
              }
            },
            "doc" : "How the partition will be represented in this model.\n\nIn the future, we'll likely add support for more structured\npredicates."
          }, {
            "name" : "sql",
            "type" : [ "null", "string" ],
            "doc" : "The raw where clause string which will be used for monitoring.\nRequired if the type is SQL.",
            "default" : null
          } ]
        } ],
        "doc" : "A definition of the specific filters that should be applied, when performing monitoring.\nIf not provided, there is no filter, and the full table is under consideration.",
        "default" : null
      } ]
    } ],
    "doc" : "An Freshness Assertion definition. This field is populated when the type is FRESHNESS.",
    "default" : null
  }, {
    "name" : "volumeAssertion",
    "type" : [ "null", {
      "type" : "record",
      "name" : "VolumeAssertionInfo",
      "doc" : "Attributes defining a dataset Volume Assertion",
      "fields" : [ {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "VolumeAssertionType",
          "symbols" : [ "ROW_COUNT_TOTAL", "ROW_COUNT_CHANGE", "INCREMENTING_SEGMENT_ROW_COUNT_TOTAL", "INCREMENTING_SEGMENT_ROW_COUNT_CHANGE" ],
          "symbolDocs" : {
            "INCREMENTING_SEGMENT_ROW_COUNT_CHANGE" : "A volume assertion that compares the row counts in neighboring \"segments\" or \"partitions\"\nof an incrementing column.\nThis can be used to track changes between subsequent date partition\nin a table, for example.",
            "INCREMENTING_SEGMENT_ROW_COUNT_TOTAL" : "A volume assertion that checks the latest \"segment\" in a table based on an incrementing\ncolumn to check whether it's row count falls into a particular range.\n\nThis can be used to monitor the row count of an incrementing date-partition column segment.",
            "ROW_COUNT_CHANGE" : "A volume assertion that is evaluated against an incremental row count of a dataset,\nor a row count change.",
            "ROW_COUNT_TOTAL" : "A volume assertion that is evaluated against the total row count of a dataset."
          }
        },
        "doc" : "The type of the volume assertion being monitored.",
        "Searchable" : { }
      }, {
        "name" : "entity",
        "type" : "string",
        "doc" : "The entity targeted by this Volume check.",
        "Relationship" : {
          "entityTypes" : [ "dataset" ],
          "name" : "Asserts"
        },
        "Searchable" : {
          "fieldType" : "URN"
        },
        "java" : {
          "class" : "com.linkedin.common.urn.Urn"
        }
      }, {
        "name" : "rowCountTotal",
        "type" : [ "null", {
          "type" : "record",
          "name" : "RowCountTotal",
          "doc" : "Attributes defining a ROW_COUNT_TOTAL volume assertion.",
          "fields" : [ {
            "name" : "operator",
            "type" : "AssertionStdOperator",
            "doc" : "The operator you'd like to apply.\n\nNote that only numeric operators are valid inputs:\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\nBETWEEN."
          }, {
            "name" : "parameters",
            "type" : "AssertionStdParameters",
            "doc" : "The parameters you'd like to provide as input to the operator.\n\nNote that only numeric parameter types are valid inputs: NUMBER."
          } ]
        } ],
        "doc" : "Produce FAILURE Assertion Result if the row count of the asset does not meet specific requirements.\nRequired if type is 'ROW_COUNT_TOTAL'",
        "default" : null
      }, {
        "name" : "rowCountChange",
        "type" : [ "null", {
          "type" : "record",
          "name" : "RowCountChange",
          "doc" : "Attributes defining a ROW_COUNT_CHANGE volume assertion.",
          "fields" : [ {
            "name" : "type",
            "type" : {
              "type" : "enum",
              "name" : "AssertionValueChangeType",
              "doc" : "An enum to represent a type of change in an assertion value, metric, or measurement.",
              "symbols" : [ "ABSOLUTE", "PERCENTAGE" ],
              "symbolDocs" : {
                "ABSOLUTE" : "A change that is defined in absolute terms.",
                "PERCENTAGE" : "A change that is defined in relative terms using percentage change\nfrom the original value."
              }
            },
            "doc" : "The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage."
          }, {
            "name" : "operator",
            "type" : "AssertionStdOperator",
            "doc" : "The operator you'd like to apply.\n\nNote that only numeric operators are valid inputs:\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\nBETWEEN."
          }, {
            "name" : "parameters",
            "type" : "AssertionStdParameters",
            "doc" : "The parameters you'd like to provide as input to the operator.\n\nNote that only numeric parameter types are valid inputs: NUMBER."
          } ]
        } ],
        "doc" : "Produce FAILURE Assertion Result if the delta row count of the asset does not meet specific requirements\nwithin a given period of time.\nRequired if type is 'ROW_COUNT_CHANGE'",
        "default" : null
      }, {
        "name" : "incrementingSegmentRowCountTotal",
        "type" : [ "null", {
          "type" : "record",
          "name" : "IncrementingSegmentRowCountTotal",
          "doc" : "Attributes defining an INCREMENTING_SEGMENT_ROW_COUNT_TOTAL volume assertion.",
          "fields" : [ {
            "name" : "segment",
            "type" : {
              "type" : "record",
              "name" : "IncrementingSegmentSpec",
              "doc" : "Core attributes required to identify an incrementing segment in a table. This type is mainly useful\nfor tables that constantly increase with new rows being added on a particular cadence (e.g. fact or event tables)\n\nAn incrementing segment represents a logical chunk of data which is INSERTED\ninto a dataset on a regular interval, along with the presence of a constantly-incrementing column\nvalue such as an event time, date partition, or last modified column.\n\nAn incrementing segment is principally identified by 2 key attributes combined:\n\n 1. A field or column that represents the incrementing value. New rows that are inserted will be identified using this column.\n    Note that the value of this column may not by itself represent the \"bucket\" or the \"segment\" in which the row falls.\n\n 2. [Optional] An transformer function that may be applied to the selected column value in order\n    to obtain the final \"segment identifier\" or \"bucket identifier\". Rows that have the same value after applying the transformation\n    will be grouped into the same segment, using which the final value (e.g. row count) will be determined.",
              "fields" : [ {
                "name" : "field",
                "type" : {
                  "type" : "record",
                  "name" : "SchemaFieldSpec",
                  "namespace" : "com.linkedin.schema",
                  "doc" : "Lightweight spec used for referencing a particular schema field.",
                  "fields" : [ {
                    "name" : "path",
                    "type" : "string",
                    "doc" : "The field path"
                  }, {
                    "name" : "type",
                    "type" : "string",
                    "doc" : "The DataHub standard schema field type."
                  }, {
                    "name" : "nativeType",
                    "type" : "string",
                    "doc" : "The native field type"
                  } ]
                },
                "doc" : "The field to use to generate segments. It must be constantly incrementing as new rows are inserted."
              }, {
                "name" : "transformer",
                "type" : [ "null", {
                  "type" : "record",
                  "name" : "IncrementingSegmentFieldTransformer",
                  "doc" : "The definition of the transformer function  that should be applied to a given field / column value in a dataset\nin order to determine the segment or bucket that it belongs to, which in turn is used to evaluate\nvolume assertions.",
                  "fields" : [ {
                    "name" : "type",
                    "type" : {
                      "type" : "enum",
                      "name" : "IncrementingSegmentFieldTransformerType",
                      "symbols" : [ "TIMESTAMP_MS_TO_MINUTE", "TIMESTAMP_MS_TO_HOUR", "TIMESTAMP_MS_TO_DATE", "TIMESTAMP_MS_TO_MONTH", "TIMESTAMP_MS_TO_YEAR", "FLOOR", "CEILING", "NATIVE" ],
                      "symbolDocs" : {
                        "CEILING" : "Rounds a numeric value up to the nearest integer.",
                        "FLOOR" : "Rounds a numeric value down to the nearest integer.",
                        "NATIVE" : "A backdoor to provide a native operator type specific to a given source system like\nSnowflake, Redshift, BQ, etc.",
                        "TIMESTAMP_MS_TO_DATE" : "Rounds a timestamp (in milliseconds) down to the start of the day.",
                        "TIMESTAMP_MS_TO_HOUR" : "Rounds a timestamp (in milliseconds) down to the nearest hour.",
                        "TIMESTAMP_MS_TO_MINUTE" : "Rounds a timestamp (in seconds) down to the start of the month.",
                        "TIMESTAMP_MS_TO_MONTH" : "Rounds a timestamp (in milliseconds) down to the start of the month",
                        "TIMESTAMP_MS_TO_YEAR" : "Rounds a timestamp (in milliseconds) down to the start of the year"
                      }
                    },
                    "doc" : "A 'standard' transformer type. Note that not all source systems will support all operators."
                  }, {
                    "name" : "nativeType",
                    "type" : [ "null", "string" ],
                    "doc" : "The 'native' transformer type, useful as a back door if a custom operator is required.\nThis field is required if the type is NATIVE.",
                    "default" : null
                  } ]
                } ],
                "doc" : "Optional transformer function to apply to the field in order to obtain the final segment or bucket identifier.\nIf not provided, then no operator will be applied to the field. (identity function)",
                "default" : null
              } ]
            },
            "doc" : "A specification of how the 'segment' can be derived using a column and an optional transformer function."
          }, {
            "name" : "operator",
            "type" : "AssertionStdOperator",
            "doc" : "The operator you'd like to apply.\n\nNote that only numeric operators are valid inputs:\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\nBETWEEN."
          }, {
            "name" : "parameters",
            "type" : "AssertionStdParameters",
            "doc" : "The parameters you'd like to provide as input to the operator.\n\nNote that only numeric parameter types are valid inputs: NUMBER."
          } ]
        } ],
        "doc" : "Produce FAILURE Assertion Result if the asset's latest incrementing segment row count total\ndoes not meet specific requirements. Required if type is 'INCREMENTING_SEGMENT_ROW_COUNT_TOTAL'",
        "default" : null
      }, {
        "name" : "incrementingSegmentRowCountChange",
        "type" : [ "null", {
          "type" : "record",
          "name" : "IncrementingSegmentRowCountChange",
          "doc" : "Attributes defining an INCREMENTING_SEGMENT_ROW_COUNT_CHANGE volume assertion.",
          "fields" : [ {
            "name" : "segment",
            "type" : "IncrementingSegmentSpec",
            "doc" : "A specification of how the 'segment' can be derived using a column and an optional transformer function."
          }, {
            "name" : "type",
            "type" : "AssertionValueChangeType",
            "doc" : "The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage."
          }, {
            "name" : "operator",
            "type" : "AssertionStdOperator",
            "doc" : "The operator you'd like to apply to the row count value\n\nNote that only numeric operators are valid inputs:\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\nBETWEEN."
          }, {
            "name" : "parameters",
            "type" : "AssertionStdParameters",
            "doc" : "The parameters you'd like to provide as input to the operator.\n\nNote that only numeric parameter types are valid inputs: NUMBER."
          } ]
        } ],
        "doc" : "Produce FAILURE Assertion Result if the asset's incrementing segment row count delta\ndoes not meet specific requirements. Required if type is 'INCREMENTING_SEGMENT_ROW_COUNT_CHANGE'",
        "default" : null
      }, {
        "name" : "filter",
        "type" : [ "null", "com.linkedin.dataset.DatasetFilter" ],
        "doc" : "A definition of the specific filters that should be applied, when performing monitoring.\nIf not provided, there is no filter, and the full table is under consideration.",
        "default" : null
      } ]
    } ],
    "doc" : "An Volume Assertion definition. This field is populated when the type is VOLUME.",
    "default" : null
  }, {
    "name" : "sqlAssertion",
    "type" : [ "null", {
      "type" : "record",
      "name" : "SqlAssertionInfo",
      "doc" : "Attributes defining a SQL Assertion",
      "fields" : [ {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "SqlAssertionType",
          "symbols" : [ "METRIC", "METRIC_CHANGE" ],
          "symbolDocs" : {
            "METRIC" : "A SQL Metric Assertion, e.g. one based on a numeric value returned by an arbitrary SQL query.",
            "METRIC_CHANGE" : "A SQL assertion that is evaluated against the CHANGE in a metric assertion\nover time."
          }
        },
        "doc" : "The type of the SQL assertion being monitored.",
        "Searchable" : { }
      }, {
        "name" : "entity",
        "type" : "string",
        "doc" : "The entity targeted by this SQL check.",
        "Relationship" : {
          "entityTypes" : [ "dataset" ],
          "name" : "Asserts"
        },
        "Searchable" : {
          "fieldType" : "URN"
        },
        "java" : {
          "class" : "com.linkedin.common.urn.Urn"
        }
      }, {
        "name" : "statement",
        "type" : "string",
        "doc" : "The SQL statement to be executed when evaluating the assertion (or computing the metric).\nThis should be a valid and complete statement, executable by itself.\n\nUsually this should be a SELECT query statement."
      }, {
        "name" : "changeType",
        "type" : [ "null", "AssertionValueChangeType" ],
        "doc" : "The type of the value used to evaluate the assertion: a fixed absolute value or a relative percentage.\nThis value is required if the type is METRIC_CHANGE.",
        "default" : null
      }, {
        "name" : "operator",
        "type" : "AssertionStdOperator",
        "doc" : "The operator you'd like to apply to the result of the SQL query.\n\nNote that at this time, only numeric operators are valid inputs:\nGREATER_THAN, GREATER_THAN_OR_EQUAL_TO, EQUAL_TO, LESS_THAN, LESS_THAN_OR_EQUAL_TO,\nBETWEEN."
      }, {
        "name" : "parameters",
        "type" : "AssertionStdParameters",
        "doc" : "The parameters you'd like to provide as input to the operator.\n\nNote that only numeric parameter types are valid inputs: NUMBER."
      } ]
    } ],
    "doc" : "A SQL Assertion definition. This field is populated when the type is SQL.",
    "default" : null
  }, {
    "name" : "fieldAssertion",
    "type" : [ "null", {
      "type" : "record",
      "name" : "FieldAssertionInfo",
      "doc" : "Attributes defining a Field Assertion.",
      "fields" : [ {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "FieldAssertionType",
          "symbols" : [ "FIELD_VALUES", "FIELD_METRIC" ],
          "symbolDocs" : {
            "FIELD_METRIC" : "An assertion used to validate the value of a common field / column metric (e.g. aggregation) such as null count + percentage,\nmin, max, median, and more.",
            "FIELD_VALUES" : "An assertion used to validate the values contained with a field / column given a set of rows."
          }
        },
        "doc" : "The type of the field assertion being monitored.",
        "Searchable" : { }
      }, {
        "name" : "entity",
        "type" : "string",
        "doc" : "The entity targeted by this Field check.",
        "Relationship" : {
          "entityTypes" : [ "dataset" ],
          "name" : "Asserts"
        },
        "Searchable" : {
          "fieldType" : "URN"
        },
        "java" : {
          "class" : "com.linkedin.common.urn.Urn"
        }
      }, {
        "name" : "fieldValuesAssertion",
        "type" : [ "null", {
          "type" : "record",
          "name" : "FieldValuesAssertion",
          "doc" : "Attributes defining a field values assertion, which asserts that the values for a field / column\nof a dataset / table matches a set of expectations.\n\nIn other words, this type of assertion acts as a semantic constraint applied to fields for a specific column.\n\nTODO: We should display the \"failed row count\" to the user if the column fails the verification rules.\nTODO: Determine whether we need an \"operator\" that can be applied to the field.",
          "fields" : [ {
            "name" : "field",
            "type" : "com.linkedin.schema.SchemaFieldSpec",
            "doc" : "The field under evaluation",
            "Searchable" : {
              "/path" : {
                "fieldName" : "fieldPath"
              }
            }
          }, {
            "name" : "transform",
            "type" : [ "null", {
              "type" : "record",
              "name" : "FieldTransform",
              "doc" : "Definition of a transform applied to the values of a column / field.\nNote that the applicability of a field transform ultimately depends on the native type\nof the field / column.\n\nModel has single field to permit extension.",
              "fields" : [ {
                "name" : "type",
                "type" : {
                  "type" : "enum",
                  "name" : "FieldTransformType",
                  "symbols" : [ "LENGTH" ],
                  "symbolDocs" : {
                    "LENGTH" : "Obtain the length of a string field / column (applicable to string types)"
                  }
                },
                "doc" : "The type of the field transform, e.g. the transformation\nfunction / operator to apply."
              } ]
            } ],
            "doc" : "An optional transform to apply to field values\nbefore evaluating the operator.\n\nIf none is applied, the field value will be compared as is.",
            "default" : null
          }, {
            "name" : "operator",
            "type" : "AssertionStdOperator",
            "doc" : "The predicate to evaluate against a single value of the field.\nDepending on the operator, parameters may be required in order to successfully\nevaluate the assertion against the field value."
          }, {
            "name" : "parameters",
            "type" : [ "null", "AssertionStdParameters" ],
            "doc" : "Standard parameters required for the assertion. e.g. min_value, max_value, value, columns",
            "default" : null
          }, {
            "name" : "failThreshold",
            "type" : {
              "type" : "record",
              "name" : "FieldValuesFailThreshold",
              "fields" : [ {
                "name" : "type",
                "type" : {
                  "type" : "enum",
                  "name" : "FieldValuesFailThresholdType",
                  "symbols" : [ "COUNT", "PERCENTAGE" ]
                },
                "doc" : "The type of failure threshold. Either based on the number\nof column values (rows) that fail the expectations, or the percentage\nof the total rows under consideration.",
                "default" : "COUNT"
              }, {
                "name" : "value",
                "type" : "long",
                "doc" : "By default this is 0, meaning that ALL column values (i.e. rows) must\nmeet the defined expectations.",
                "default" : 0
              } ]
            },
            "doc" : "Additional customization about when the assertion\nshould be officially considered failing."
          }, {
            "name" : "excludeNulls",
            "type" : "boolean",
            "doc" : "Whether to ignore or allow nulls when running the values assertion. (i.e.\nconsider only non-null values) using operators OTHER than the IS_NULL operator.\n\nDefaults to true, allowing null values.",
            "default" : true
          } ]
        } ],
        "doc" : "The definition of an assertion that validates individual values of a field / column for a set of rows.\nThis type of assertion verifies that each column value meets a particular requirement.",
        "default" : null
      }, {
        "name" : "fieldMetricAssertion",
        "type" : [ "null", {
          "type" : "record",
          "name" : "FieldMetricAssertion",
          "doc" : "Attributes defining a field metric assertion, which asserts an expectation against\na common metric derived from the set of field / column values, for example:\nmax, min, median, null count, null percentage, unique count, unique percentage, and more.",
          "fields" : [ {
            "name" : "field",
            "type" : "com.linkedin.schema.SchemaFieldSpec",
            "doc" : "The field under evaluation",
            "Searchable" : {
              "/path" : {
                "fieldName" : "fieldPath"
              }
            }
          }, {
            "name" : "metric",
            "type" : {
              "type" : "enum",
              "name" : "FieldMetricType",
              "doc" : "A standard metric that can be derived from the set of values\nfor a specific field / column of a dataset / table.",
              "symbols" : [ "UNIQUE_COUNT", "UNIQUE_PERCENTAGE", "NULL_COUNT", "NULL_PERCENTAGE", "MIN", "MAX", "MEAN", "MEDIAN", "STDDEV", "NEGATIVE_COUNT", "NEGATIVE_PERCENTAGE", "ZERO_COUNT", "ZERO_PERCENTAGE", "MIN_LENGTH", "MAX_LENGTH", "EMPTY_COUNT", "EMPTY_PERCENTAGE" ],
              "symbolDocs" : {
                "EMPTY_COUNT" : "The number of empty string values found in the value set (applies to string columns).\nNote: This is a completely different metric different from NULL_COUNT!",
                "EMPTY_PERCENTAGE" : "The percentage of empty string values to total rows for the dataset (applies to string columns)\nNote: This is a completely different metric different from NULL_PERCENTAGE!",
                "MAX" : "The maximum value in the column set (applies to numeric columns)",
                "MAX_LENGTH" : "The maximum length found in the column set (applies to string columns)",
                "MEAN" : "The mean length found in the column set (applies to numeric columns)",
                "MEDIAN" : "The median length found in the column set (applies to numeric columns)",
                "MIN" : "The minimum value in the column set (applies to numeric columns)",
                "MIN_LENGTH" : "The minimum length found in the column set (applies to string columns)",
                "NEGATIVE_COUNT" : "The number of negative values found in the value set (applies to numeric columns)",
                "NEGATIVE_PERCENTAGE" : "The percentage of negative values to total rows for the dataset (applies to numeric columns)",
                "NULL_COUNT" : "The number of null values found in the column value set",
                "NULL_PERCENTAGE" : "The percentage of null values to total rows for the dataset",
                "STDDEV" : "The stddev length found in the column set (applies to numeric columns)",
                "UNIQUE_COUNT" : "The number of unique values found in the column value set",
                "UNIQUE_PERCENTAGE" : "The percentage of unique values to total rows for the dataset",
                "ZERO_COUNT" : "The number of zero values found in the value set (applies to numeric columns)",
                "ZERO_PERCENTAGE" : "The percentage of zero values to total rows for the dataset (applies to numeric columns)"
              }
            },
            "doc" : "The specific metric to assert against. This is the value that\nwill be obtained by applying a standard operation, such as an aggregation,\nto the selected field."
          }, {
            "name" : "operator",
            "type" : "AssertionStdOperator",
            "doc" : "The predicate to evaluate against the metric for the field / column.\nDepending on the operator, parameters may be required in order to successfully\nevaluate the assertion against the metric value."
          }, {
            "name" : "parameters",
            "type" : [ "null", "AssertionStdParameters" ],
            "doc" : "Standard parameters required for the assertion. e.g. min_value, max_value, value, columns",
            "default" : null
          } ]
        } ],
        "doc" : "The definition of an assertion that validates a common metric obtained about a field / column for a set of rows.\nThis type of assertion verifies that the value of a high-level metric obtained by aggregating over a column meets\nexpectations",
        "default" : null
      }, {
        "name" : "filter",
        "type" : [ "null", "com.linkedin.dataset.DatasetFilter" ],
        "doc" : "A definition of the specific filters that should be applied, when performing monitoring.\nIf not provided, there is no filter, and the full table is under consideration.\nIf using DataHub Dataset Profiles as the assertion source type, the value of this field will be ignored.",
        "default" : null
      } ]
    } ],
    "doc" : "A Field Assertion definition. This field is populated when the type is FIELD.",
    "default" : null
  }, {
    "name" : "schemaAssertion",
    "type" : [ "null", {
      "type" : "record",
      "name" : "SchemaAssertionInfo",
      "doc" : "Attributes that are applicable to schema assertions",
      "fields" : [ {
        "name" : "entity",
        "type" : "string",
        "doc" : "The entity targeted by the assertion",
        "Relationship" : {
          "entityTypes" : [ "dataset", "dataJob" ],
          "name" : "Asserts"
        },
        "Searchable" : {
          "fieldType" : "URN"
        },
        "java" : {
          "class" : "com.linkedin.common.urn.Urn"
        }
      }, {
        "name" : "schema",
        "type" : {
          "type" : "record",
          "name" : "SchemaMetadata",
          "namespace" : "com.linkedin.schema",
          "doc" : "SchemaMetadata to describe metadata related to store schema",
          "fields" : [ {
            "name" : "schemaName",
            "type" : "string",
            "doc" : "Schema name e.g. PageViewEvent, identity.Profile, ams.account_management_tracking",
            "validate" : {
              "strlen" : {
                "max" : 500,
                "min" : 1
              }
            }
          }, {
            "name" : "platform",
            "type" : "string",
            "doc" : "Standardized platform urn where schema is defined. The data platform Urn (urn:li:platform:{platform_name})",
            "java" : {
              "class" : "com.linkedin.common.urn.DataPlatformUrn"
            }
          }, {
            "name" : "version",
            "type" : "long",
            "doc" : "Every change to SchemaMetadata in the resource results in a new version. Version is server assigned. This version is differ from platform native schema version."
          }, {
            "name" : "created",
            "type" : {
              "type" : "record",
              "name" : "AuditStamp",
              "namespace" : "com.linkedin.common",
              "doc" : "Data captured on a resource/association/sub-resource level giving insight into when that resource/association/sub-resource moved into a particular lifecycle stage, and who acted to move it into that specific lifecycle stage.",
              "fields" : [ {
                "name" : "time",
                "type" : "long",
                "doc" : "When did the resource/association/sub-resource move into the specific lifecycle stage represented by this AuditEvent."
              }, {
                "name" : "actor",
                "type" : "string",
                "doc" : "The entity (e.g. a member URN) which will be credited for moving the resource/association/sub-resource into the specific lifecycle stage. It is also the one used to authorize the change.",
                "java" : {
                  "class" : "com.linkedin.common.urn.Urn"
                }
              }, {
                "name" : "impersonator",
                "type" : [ "null", "string" ],
                "doc" : "The entity (e.g. a service URN) which performs the change on behalf of the Actor and must be authorized to act as the Actor.",
                "default" : null,
                "java" : {
                  "class" : "com.linkedin.common.urn.Urn"
                }
              }, {
                "name" : "message",
                "type" : [ "null", "string" ],
                "doc" : "Additional context around how DataHub was informed of the particular change. For example: was the change created by an automated process, or manually.",
                "default" : null
              } ]
            },
            "doc" : "An AuditStamp corresponding to the creation of this resource/association/sub-resource. A value of 0 for time indicates missing data.",
            "default" : {
              "actor" : "urn:li:corpuser:unknown",
              "impersonator" : null,
              "time" : 0,
              "message" : null
            }
          }, {
            "name" : "lastModified",
            "type" : "com.linkedin.common.AuditStamp",
            "doc" : "An AuditStamp corresponding to the last modification of this resource/association/sub-resource. If no modification has happened since creation, lastModified should be the same as created. A value of 0 for time indicates missing data.",
            "default" : {
              "actor" : "urn:li:corpuser:unknown",
              "impersonator" : null,
              "time" : 0,
              "message" : null
            }
          }, {
            "name" : "deleted",
            "type" : [ "null", "com.linkedin.common.AuditStamp" ],
            "doc" : "An AuditStamp corresponding to the deletion of this resource/association/sub-resource. Logically, deleted MUST have a later timestamp than creation. It may or may not have the same time as lastModified depending upon the resource/association/sub-resource semantics.",
            "default" : null
          }, {
            "name" : "dataset",
            "type" : [ "null", "string" ],
            "doc" : "Dataset this schema metadata is associated with.",
            "default" : null,
            "java" : {
              "class" : "com.linkedin.common.urn.DatasetUrn"
            }
          }, {
            "name" : "cluster",
            "type" : [ "null", "string" ],
            "doc" : "The cluster this schema metadata resides from",
            "default" : null
          }, {
            "name" : "hash",
            "type" : "string",
            "doc" : "the SHA1 hash of the schema content"
          }, {
            "name" : "platformSchema",
            "type" : [ {
              "type" : "record",
              "name" : "EspressoSchema",
              "doc" : "Schema text of an espresso table schema.",
              "fields" : [ {
                "name" : "documentSchema",
                "type" : "string",
                "doc" : "The native espresso document schema."
              }, {
                "name" : "tableSchema",
                "type" : "string",
                "doc" : "The espresso table schema definition."
              } ]
            }, {
              "type" : "record",
              "name" : "OracleDDL",
              "doc" : "Schema holder for oracle data definition language that describes an oracle table.",
              "fields" : [ {
                "name" : "tableSchema",
                "type" : "string",
                "doc" : "The native schema in the dataset's platform. This is a human readable (json blob) table schema."
              } ]
            }, {
              "type" : "record",
              "name" : "MySqlDDL",
              "doc" : "Schema holder for MySql data definition language that describes an MySql table.",
              "fields" : [ {
                "name" : "tableSchema",
                "type" : "string",
                "doc" : "The native schema in the dataset's platform. This is a human readable (json blob) table schema."
              } ]
            }, {
              "type" : "record",
              "name" : "PrestoDDL",
              "doc" : "Schema holder for presto data definition language that describes a presto view.",
              "fields" : [ {
                "name" : "rawSchema",
                "type" : "string",
                "doc" : "The raw schema in the dataset's platform. This includes the DDL and the columns extracted from DDL."
              } ]
            }, {
              "type" : "record",
              "name" : "KafkaSchema",
              "doc" : "Schema holder for kafka schema.",
              "fields" : [ {
                "name" : "documentSchema",
                "type" : "string",
                "doc" : "The native kafka document schema. This is a human readable avro document schema."
              }, {
                "name" : "documentSchemaType",
                "type" : [ "null", "string" ],
                "doc" : "The native kafka document schema type. This can be AVRO/PROTOBUF/JSON.",
                "default" : null
              }, {
                "name" : "keySchema",
                "type" : [ "null", "string" ],
                "doc" : "The native kafka key schema as retrieved from Schema Registry",
                "default" : null
              }, {
                "name" : "keySchemaType",
                "type" : [ "null", "string" ],
                "doc" : "The native kafka key schema type. This can be AVRO/PROTOBUF/JSON.",
                "default" : null
              } ]
            }, {
              "type" : "record",
              "name" : "BinaryJsonSchema",
              "doc" : "Schema text of binary JSON schema.",
              "fields" : [ {
                "name" : "schema",
                "type" : "string",
                "doc" : "The native schema text for binary JSON file format."
              } ]
            }, {
              "type" : "record",
              "name" : "OrcSchema",
              "doc" : "Schema text of an ORC schema.",
              "fields" : [ {
                "name" : "schema",
                "type" : "string",
                "doc" : "The native schema for ORC file format."
              } ]
            }, {
              "type" : "record",
              "name" : "Schemaless",
              "doc" : "The dataset has no specific schema associated with it",
              "fields" : [ ]
            }, {
              "type" : "record",
              "name" : "KeyValueSchema",
              "doc" : "Schema text of a key-value store schema.",
              "fields" : [ {
                "name" : "keySchema",
                "type" : "string",
                "doc" : "The raw schema for the key in the key-value store."
              }, {
                "name" : "valueSchema",
                "type" : "string",
                "doc" : "The raw schema for the value in the key-value store."
              } ]
            }, {
              "type" : "record",
              "name" : "OtherSchema",
              "doc" : "Schema holder for undefined schema types.",
              "fields" : [ {
                "name" : "rawSchema",
                "type" : "string",
                "doc" : "The native schema in the dataset's platform."
              } ]
            } ],
            "doc" : "The native schema in the dataset's platform."
          }, {
            "name" : "fields",
            "type" : {
              "type" : "array",
              "items" : {
                "type" : "record",
                "name" : "SchemaField",
                "doc" : "SchemaField to describe metadata related to dataset schema.",
                "fields" : [ {
                  "name" : "fieldPath",
                  "type" : "string",
                  "doc" : "Flattened name of the field. Field is computed from jsonPath field.",
                  "Searchable" : {
                    "boostScore" : 1.0,
                    "fieldName" : "fieldPaths",
                    "fieldType" : "TEXT",
                    "queryByDefault" : "true"
                  }
                }, {
                  "name" : "jsonPath",
                  "type" : [ "null", "string" ],
                  "doc" : "Flattened name of a field in JSON Path notation.",
                  "default" : null,
                  "Deprecated" : true
                }, {
                  "name" : "nullable",
                  "type" : "boolean",
                  "doc" : "Indicates if this field is optional or nullable",
                  "default" : false
                }, {
                  "name" : "description",
                  "type" : [ "null", "string" ],
                  "doc" : "Description",
                  "default" : null,
                  "Searchable" : {
                    "boostScore" : 0.1,
                    "fieldName" : "fieldDescriptions",
                    "fieldType" : "TEXT"
                  }
                }, {
                  "name" : "label",
                  "type" : [ "null", "string" ],
                  "doc" : "Label of the field. Provides a more human-readable name for the field than field path. Some sources will\nprovide this metadata but not all sources have the concept of a label. If just one string is associated with\na field in a source, that is most likely a description.\n\nNote that this field is deprecated and is not surfaced in the UI.",
                  "default" : null,
                  "Deprecated" : true,
                  "Searchable" : {
                    "boostScore" : 0.2,
                    "fieldName" : "fieldLabels",
                    "fieldType" : "TEXT"
                  }
                }, {
                  "name" : "created",
                  "type" : [ "null", "com.linkedin.common.AuditStamp" ],
                  "doc" : "An AuditStamp corresponding to the creation of this schema field.",
                  "default" : null
                }, {
                  "name" : "lastModified",
                  "type" : [ "null", "com.linkedin.common.AuditStamp" ],
                  "doc" : "An AuditStamp corresponding to the last modification of this schema field.",
                  "default" : null
                }, {
                  "name" : "type",
                  "type" : {
                    "type" : "record",
                    "name" : "SchemaFieldDataType",
                    "doc" : "Schema field data types",
                    "fields" : [ {
                      "name" : "type",
                      "type" : [ {
                        "type" : "record",
                        "name" : "BooleanType",
                        "doc" : "Boolean field type.",
                        "fields" : [ ]
                      }, {
                        "type" : "record",
                        "name" : "FixedType",
                        "doc" : "Fixed field type.",
                        "fields" : [ ]
                      }, {
                        "type" : "record",
                        "name" : "StringType",
                        "doc" : "String field type.",
                        "fields" : [ ]
                      }, {
                        "type" : "record",
                        "name" : "BytesType",
                        "doc" : "Bytes field type.",
                        "fields" : [ ]
                      }, {
                        "type" : "record",
                        "name" : "NumberType",
                        "doc" : "Number data type: long, integer, short, etc..",
                        "fields" : [ ]
                      }, {
                        "type" : "record",
                        "name" : "DateType",
                        "doc" : "Date field type.",
                        "fields" : [ ]
                      }, {
                        "type" : "record",
                        "name" : "TimeType",
                        "doc" : "Time field type. This should also be used for datetimes.",
                        "fields" : [ ]
                      }, {
                        "type" : "record",
                        "name" : "EnumType",
                        "doc" : "Enum field type.",
                        "fields" : [ ]
                      }, {
                        "type" : "record",
                        "name" : "NullType",
                        "doc" : "Null field type.",
                        "fields" : [ ]
                      }, {
                        "type" : "record",
                        "name" : "MapType",
                        "doc" : "Map field type.",
                        "fields" : [ {
                          "name" : "keyType",
                          "type" : [ "null", "string" ],
                          "doc" : "Key type in a map",
                          "default" : null
                        }, {
                          "name" : "valueType",
                          "type" : [ "null", "string" ],
                          "doc" : "Type of the value in a map",
                          "default" : null
                        } ]
                      }, {
                        "type" : "record",
                        "name" : "ArrayType",
                        "doc" : "Array field type.",
                        "fields" : [ {
                          "name" : "nestedType",
                          "type" : [ "null", {
                            "type" : "array",
                            "items" : "string"
                          } ],
                          "doc" : "List of types this array holds.",
                          "default" : null
                        } ]
                      }, {
                        "type" : "record",
                        "name" : "UnionType",
                        "doc" : "Union field type.",
                        "fields" : [ {
                          "name" : "nestedTypes",
                          "type" : [ "null", {
                            "type" : "array",
                            "items" : "string"
                          } ],
                          "doc" : "List of types in union type.",
                          "default" : null
                        } ]
                      }, {
                        "type" : "record",
                        "name" : "RecordType",
                        "doc" : "Record field type.",
                        "fields" : [ ]
                      } ],
                      "doc" : "Data platform specific types"
                    } ]
                  },
                  "doc" : "Platform independent field type of the field."
                }, {
                  "name" : "nativeDataType",
                  "type" : "string",
                  "doc" : "The native type of the field in the dataset's platform as declared by platform schema."
                }, {
                  "name" : "recursive",
                  "type" : "boolean",
                  "doc" : "There are use cases when a field in type B references type A. A field in A references field of type B. In such cases, we will mark the first field as recursive.",
                  "default" : false
                }, {
                  "name" : "globalTags",
                  "type" : [ "null", {
                    "type" : "record",
                    "name" : "GlobalTags",
                    "namespace" : "com.linkedin.common",
                    "doc" : "Tag aspect used for applying tags to an entity",
                    "fields" : [ {
                      "name" : "tags",
                      "type" : {
                        "type" : "array",
                        "items" : {
                          "type" : "record",
                          "name" : "TagAssociation",
                          "doc" : "Properties of an applied tag. For now, just an Urn. In the future we can extend this with other properties, e.g.\npropagation parameters.",
                          "fields" : [ {
                            "name" : "tag",
                            "type" : "string",
                            "doc" : "Urn of the applied tag",
                            "java" : {
                              "class" : "com.linkedin.common.urn.TagUrn"
                            }
                          }, {
                            "name" : "context",
                            "type" : [ "null", "string" ],
                            "doc" : "Additional context about the association",
                            "default" : null
                          }, {
                            "name" : "attribution",
                            "type" : [ "null", {
                              "type" : "record",
                              "name" : "MetadataAttribution",
                              "doc" : "Information about who, why, and how this metadata was applied",
                              "fields" : [ {
                                "name" : "time",
                                "type" : "long",
                                "doc" : "When this metadata was updated."
                              }, {
                                "name" : "actor",
                                "type" : "string",
                                "doc" : "The entity (e.g. a member URN) responsible for applying the assocated metadata. This can\neither be a user (in case of UI edits) or the datahub system for automation.",
                                "java" : {
                                  "class" : "com.linkedin.common.urn.Urn"
                                }
                              }, {
                                "name" : "source",
                                "type" : [ "null", "string" ],
                                "doc" : "The DataHub source responsible for applying the associated metadata. This will only be filled out\nwhen a DataHub source is responsible. This includes the specific metadata test urn, the automation urn.",
                                "default" : null,
                                "java" : {
                                  "class" : "com.linkedin.common.urn.Urn"
                                }
                              }, {
                                "name" : "sourceDetail",
                                "type" : {
                                  "type" : "map",
                                  "values" : "string"
                                },
                                "doc" : "The details associated with why this metadata was applied. For example, this could include\nthe actual regex rule, sql statement, ingestion pipeline ID, etc.",
                                "default" : { }
                              } ]
                            } ],
                            "doc" : "Information about who, why, and how this metadata was applied",
                            "default" : null,
                            "Searchable" : {
                              "/actor" : {
                                "fieldName" : "tagAttributionActors",
                                "fieldType" : "URN",
                                "queryByDefault" : false
                              },
                              "/source" : {
                                "fieldName" : "tagAttributionSources",
                                "fieldType" : "URN",
                                "queryByDefault" : false
                              },
                              "/time" : {
                                "fieldName" : "tagAttributionDates",
                                "fieldType" : "DATETIME",
                                "queryByDefault" : false
                              }
                            }
                          } ]
                        }
                      },
                      "doc" : "Tags associated with a given entity",
                      "Relationship" : {
                        "/*/tag" : {
                          "entityTypes" : [ "tag" ],
                          "name" : "TaggedWith"
                        }
                      },
                      "Searchable" : {
                        "/*/tag" : {
                          "addToFilters" : true,
                          "boostScore" : 0.5,
                          "fieldName" : "tags",
                          "fieldType" : "URN",
                          "filterNameOverride" : "Tagged With",
                          "hasValuesFieldName" : "hasTags",
                          "queryByDefault" : true,
                          "searchTier" : 2
                        }
                      }
                    } ],
                    "Aspect" : {
                      "name" : "globalTags"
                    }
                  } ],
                  "doc" : "Tags associated with the field",
                  "default" : null,
                  "Relationship" : {
                    "/tags/*/tag" : {
                      "entityTypes" : [ "tag" ],
                      "name" : "SchemaFieldTaggedWith"
                    }
                  },
                  "Searchable" : {
                    "/tags/*/attribution/actor" : {
                      "fieldName" : "fieldTagAttributionActors",
                      "fieldType" : "URN",
                      "queryByDefault" : false
                    },
                    "/tags/*/attribution/source" : {
                      "fieldName" : "fieldTagAttributionSources",
                      "fieldType" : "URN",
                      "queryByDefault" : false
                    },
                    "/tags/*/attribution/time" : {
                      "fieldName" : "fieldTagAttributionDates",
                      "fieldType" : "DATETIME",
                      "queryByDefault" : false
                    },
                    "/tags/*/tag" : {
                      "boostScore" : 0.5,
                      "fieldName" : "fieldTags",
                      "fieldType" : "URN"
                    }
                  }
                }, {
                  "name" : "glossaryTerms",
                  "type" : [ "null", {
                    "type" : "record",
                    "name" : "GlossaryTerms",
                    "namespace" : "com.linkedin.common",
                    "doc" : "Related business terms information",
                    "fields" : [ {
                      "name" : "terms",
                      "type" : {
                        "type" : "array",
                        "items" : {
                          "type" : "record",
                          "name" : "GlossaryTermAssociation",
                          "doc" : "Properties of an applied glossary term.",
                          "fields" : [ {
                            "name" : "urn",
                            "type" : "string",
                            "doc" : "Urn of the applied glossary term",
                            "Relationship" : {
                              "entityTypes" : [ "glossaryTerm" ],
                              "name" : "TermedWith"
                            },
                            "Searchable" : {
                              "addToFilters" : true,
                              "fieldName" : "glossaryTerms",
                              "fieldType" : "URN",
                              "filterNameOverride" : "Glossary Term",
                              "hasValuesFieldName" : "hasGlossaryTerms",
                              "includeSystemModifiedAt" : true,
                              "systemModifiedAtFieldName" : "termsModifiedAt"
                            },
                            "java" : {
                              "class" : "com.linkedin.common.urn.GlossaryTermUrn"
                            }
                          }, {
                            "name" : "actor",
                            "type" : [ "null", "string" ],
                            "doc" : "The user URN which will be credited for adding associating this term to the entity",
                            "default" : null,
                            "java" : {
                              "class" : "com.linkedin.common.urn.Urn"
                            }
                          }, {
                            "name" : "context",
                            "type" : [ "null", "string" ],
                            "doc" : "Additional context about the association",
                            "default" : null
                          }, {
                            "name" : "attribution",
                            "type" : [ "null", "MetadataAttribution" ],
                            "doc" : "Information about who, why, and how this metadata was applied",
                            "default" : null,
                            "Searchable" : {
                              "/actor" : {
                                "fieldName" : "termAttributionActors",
                                "fieldType" : "URN",
                                "queryByDefault" : false
                              },
                              "/source" : {
                                "fieldName" : "termAttributionSources",
                                "fieldType" : "URN",
                                "queryByDefault" : false
                              },
                              "/time" : {
                                "fieldName" : "termAttributionDates",
                                "fieldType" : "DATETIME",
                                "queryByDefault" : false
                              }
                            }
                          } ]
                        }
                      },
                      "doc" : "The related business terms"
                    }, {
                      "name" : "auditStamp",
                      "type" : "AuditStamp",
                      "doc" : "Audit stamp containing who reported the related business term"
                    } ],
                    "Aspect" : {
                      "name" : "glossaryTerms"
                    }
                  } ],
                  "doc" : "Glossary terms associated with the field",
                  "default" : null,
                  "Relationship" : {
                    "/terms/*/urn" : {
                      "entityTypes" : [ "glossaryTerm" ],
                      "name" : "SchemaFieldWithGlossaryTerm"
                    }
                  },
                  "Searchable" : {
                    "/terms/*/attribution/actor" : {
                      "fieldName" : "fieldTermAttributionActors",
                      "fieldType" : "URN",
                      "queryByDefault" : false
                    },
                    "/terms/*/attribution/source" : {
                      "fieldName" : "fieldTermAttributionSources",
                      "fieldType" : "URN",
                      "queryByDefault" : false
                    },
                    "/terms/*/attribution/time" : {
                      "fieldName" : "fieldTermAttributionDates",
                      "fieldType" : "DATETIME",
                      "queryByDefault" : false
                    },
                    "/terms/*/urn" : {
                      "boostScore" : 0.5,
                      "fieldName" : "fieldGlossaryTerms",
                      "fieldType" : "URN"
                    }
                  }
                }, {
                  "name" : "isPartOfKey",
                  "type" : "boolean",
                  "doc" : "For schema fields that are part of complex keys, set this field to true\nWe do this to easily distinguish between value and key fields",
                  "default" : false
                }, {
                  "name" : "isPartitioningKey",
                  "type" : [ "null", "boolean" ],
                  "doc" : "For Datasets which are partitioned, this determines the partitioning key.\nNote that multiple columns can be part of a partitioning key, but currently we do not support\nrendering the ordered partitioning key.",
                  "default" : null
                }, {
                  "name" : "jsonProps",
                  "type" : [ "null", "string" ],
                  "doc" : "For schema fields that have other properties that are not modeled explicitly,\nuse this field to serialize those properties into a JSON string",
                  "default" : null
                } ]
              }
            },
            "doc" : "Client provided a list of fields from document schema."
          }, {
            "name" : "primaryKeys",
            "type" : [ "null", {
              "type" : "array",
              "items" : "string"
            } ],
            "doc" : "Client provided list of fields that define primary keys to access record. Field order defines hierarchical espresso keys. Empty lists indicates absence of primary key access patter. Value is a SchemaField@fieldPath.",
            "default" : null
          }, {
            "name" : "foreignKeysSpecs",
            "type" : [ "null", {
              "type" : "map",
              "values" : {
                "type" : "record",
                "name" : "ForeignKeySpec",
                "doc" : "Description of a foreign key in a schema.",
                "fields" : [ {
                  "name" : "foreignKey",
                  "type" : [ {
                    "type" : "record",
                    "name" : "DatasetFieldForeignKey",
                    "doc" : "For non-urn based foregin keys.",
                    "fields" : [ {
                      "name" : "parentDataset",
                      "type" : "string",
                      "doc" : "dataset that stores the resource.",
                      "java" : {
                        "class" : "com.linkedin.common.urn.DatasetUrn"
                      }
                    }, {
                      "name" : "currentFieldPaths",
                      "type" : {
                        "type" : "array",
                        "items" : "string"
                      },
                      "doc" : "List of fields in hosting(current) SchemaMetadata that conform a foreign key. List can contain a single entry or multiple entries if several entries in hosting schema conform a foreign key in a single parent dataset."
                    }, {
                      "name" : "parentField",
                      "type" : "string",
                      "doc" : "SchemaField@fieldPath that uniquely identify field in parent dataset that this field references."
                    } ]
                  }, {
                    "type" : "record",
                    "name" : "UrnForeignKey",
                    "doc" : "If SchemaMetadata fields make any external references and references are of type com.linkedin.common.Urn or any children, this models can be used to mark it.",
                    "fields" : [ {
                      "name" : "currentFieldPath",
                      "type" : "string",
                      "doc" : "Field in hosting(current) SchemaMetadata."
                    } ]
                  } ],
                  "doc" : "Foreign key definition in metadata schema."
                } ]
              }
            } ],
            "doc" : "Map captures all the references schema makes to external datasets. Map key is ForeignKeySpecName typeref.",
            "default" : null,
            "deprecated" : "Use foreignKeys instead."
          }, {
            "name" : "foreignKeys",
            "type" : [ "null", {
              "type" : "array",
              "items" : {
                "type" : "record",
                "name" : "ForeignKeyConstraint",
                "doc" : "Description of a foreign key constraint in a schema.",
                "fields" : [ {
                  "name" : "name",
                  "type" : "string",
                  "doc" : "Name of the constraint, likely provided from the source"
                }, {
                  "name" : "foreignFields",
                  "type" : {
                    "type" : "array",
                    "items" : "string"
                  },
                  "doc" : "Fields the constraint maps to on the foreign dataset",
                  "Relationship" : {
                    "/*" : {
                      "entityTypes" : [ "schemaField" ],
                      "name" : "ForeignKeyTo"
                    }
                  }
                }, {
                  "name" : "sourceFields",
                  "type" : {
                    "type" : "array",
                    "items" : "string"
                  },
                  "doc" : "Fields the constraint maps to on the source dataset"
                }, {
                  "name" : "foreignDataset",
                  "type" : "string",
                  "doc" : "Reference to the foreign dataset for ease of lookup",
                  "Relationship" : {
                    "entityTypes" : [ "dataset" ],
                    "name" : "ForeignKeyToDataset"
                  },
                  "java" : {
                    "class" : "com.linkedin.common.urn.Urn"
                  }
                } ]
              }
            } ],
            "doc" : "List of foreign key constraints for the schema",
            "default" : null
          } ],
          "Aspect" : {
            "name" : "schemaMetadata"
          }
        },
        "doc" : "A definition of the expected structure for the asset\n\nNote that many of the fields of this model, especially those related to metadata (tags, terms)\nwill go unused in this context."
      }, {
        "name" : "compatibility",
        "type" : [ {
          "type" : "enum",
          "name" : "SchemaAssertionCompatibility",
          "symbols" : [ "EXACT_MATCH", "SUPERSET", "SUBSET" ],
          "symbolDocs" : {
            "EXACT_MATCH" : "The actual schema must be exactly the same as the expected schema",
            "SUBSET" : "The actual schema must be a subset of the expected schema",
            "SUPERSET" : "The actual schema must be a superset of the expected schema"
          }
        }, "null" ],
        "doc" : "The required compatibility level for the schema assertion to pass.",
        "default" : "EXACT_MATCH"
      } ]
    } ],
    "doc" : "An schema Assertion definition. This field is populated when the type is DATA_SCHEMA",
    "default" : null
  }, {
    "name" : "customAssertion",
    "type" : [ "null", {
      "type" : "record",
      "name" : "CustomAssertionInfo",
      "doc" : "Attributes that are applicable to Custom Assertions",
      "fields" : [ {
        "name" : "type",
        "type" : "string",
        "doc" : "The type of custom assertion.\nThis is how your assertion will appear categorized in DataHub UI. ",
        "Searchable" : {
          "fieldName" : "customType"
        }
      }, {
        "name" : "entity",
        "type" : "string",
        "doc" : "The entity targeted by this assertion.\nThis can have support more entityTypes (e.g. dataJob) in future",
        "Relationship" : {
          "entityTypes" : [ "dataset" ],
          "name" : "Asserts"
        },
        "java" : {
          "class" : "com.linkedin.common.urn.Urn"
        }
      }, {
        "name" : "field",
        "type" : [ "null", "string" ],
        "doc" : "dataset schema field targeted by this assertion.\n\nThis field is expected to be provided if the assertion is on dataset field",
        "default" : null,
        "Relationship" : {
          "entityTypes" : [ "schemaField" ],
          "name" : "Asserts"
        },
        "java" : {
          "class" : "com.linkedin.common.urn.Urn"
        }
      }, {
        "name" : "logic",
        "type" : [ "null", "string" ],
        "default" : null
      } ]
    } ],
    "doc" : "A Custom Assertion definition. This field is populated when type is CUSTOM.",
    "default" : null
  }, {
    "name" : "source",
    "type" : [ "null", {
      "type" : "record",
      "name" : "AssertionSource",
      "doc" : "The source of an assertion",
      "fields" : [ {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "AssertionSourceType",
          "symbols" : [ "NATIVE", "EXTERNAL", "INFERRED" ],
          "symbolDocs" : {
            "EXTERNAL" : "The assertion was defined and managed externally of DataHub.",
            "INFERRED" : "The assertion was inferred, e.g. from offline AI / ML models.\nDataHub Cloud only",
            "NATIVE" : "The assertion was defined natively on DataHub by a user.\nDataHub Cloud only"
          }
        },
        "doc" : "The type of the Assertion Source",
        "Searchable" : {
          "fieldName" : "sourceType"
        }
      }, {
        "name" : "created",
        "type" : [ "null", "com.linkedin.common.AuditStamp" ],
        "doc" : "The time at which the assertion was initially created and the author who created it.\nThis field is only present for Native assertions created after this field was introduced.",
        "default" : null
      } ]
    } ],
    "doc" : "The source or origin of the Assertion definition.\n\nIf the source type of the Assertion is EXTERNAL, it is expected to have a corresponding dataPlatformInstance aspect detailing\nthe platform where it was ingested from.",
    "default" : null
  }, {
    "name" : "lastUpdated",
    "type" : [ "null", "com.linkedin.common.AuditStamp" ],
    "doc" : "The time at which the assertion was last updated and the actor who updated it.\nThis field is only present for Native assertions updated after this field was introduced.",
    "default" : null
  }, {
    "name" : "description",
    "type" : [ "null", "string" ],
    "doc" : "An optional human-readable description of the assertion",
    "default" : null
  } ],
  "Aspect" : {
    "name" : "assertionInfo"
  }
}